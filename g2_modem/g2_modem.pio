;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

.program g2_modem

; input mapping
; bit 0..7  data
; bit 8..15 address
; bit 16    nWR
; bit 17    nRD
; bit 18    nCS

.define nWR_read 16
.define nRD_read 17
.define nCS_read 18

; configure fifo to autopush, 17 bits, autopull 8 bits
; push format
; 0 aaaa aaaa dddd dddd is a write
; 1 aaaa aaaa ???? ???? is a read

loop:
    wait 1 pin nCS_read ; wait for clear CS
    wait 0 pin nCS_read ; wait to select the chip

wait_rw:
    .wrap_target
    in pins, 18
    mov osr, isr ; clears isr
    out x, 1     ; bit 17 -> x -> nRD
    out y, 1     ; bit 16 -> y -> nWR
    jmp x!=y, read_or_write; read or write
    .wrap

read_or_write:
    mov isr, x ; copy r/w bit into isr
    in osr, 16 ; shift 16 bits into isr from osr
    push block ; push 16b + r/w bit

    jmp !y, read

write:
    wait 1 pin nRD_read ; wait for nRD
    jmp loop

read:
    mov osr, ~null  ; set osr to all 1s
    out pindirs, 8  ; we need to flip 8 data pins here

    pull block      ; get data to osr from pico
    out pins, 8     ; output data to pins

    wait 1 pin nWR_read ; wait for nWR
    set pindirs, 0
    jmp loop


% c-sdk {
static inline void g2_modem_program_init(PIO pio, uint sm, uint offset, uint base_pin) {
    pio_sm_config c = g2_modem_program_get_default_config(offset);

    sm_config_set_in_pins(&c, base_pin);

    sm_config_set_out_pins(&c, base_pin, 8);

    for (uint i = 0; i <8; i++)
        pio_gpio_init(pio, base_pin + i);
    
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 19, false);

    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}
%}